# Домашние задания 

### Домашнее задание 1. Хэширование
* Разработайте Java-программу `CalcMD5`, которая подсчитывает [MD5-хэши](https://en.wikipedia.org/wiki/MD5) файлов. 
* Программа должна принимать один аргумент командной строки — имя файла, в котором содержатся имена файлов, для которых требуется подсчитать хэши. Файлы перечислены по одному на строке. 
* Программа должна выдать на стандартный вывод MD5-хэши файлов в порядке их перечисления во входном файле. Хэши должны выдаваться в виде 32-значных шестнадцатеричных чисел. 
* Например, если файл `input.txt` содержит только `input.txt` (9 символов), то при запуске `java CalcMD5 input.txt`, на консоль должно быть выведено `A8546347050ADC932FBEC189DC9FD50D`. 
* Примечания:
  * Стандартная библиотека Java содержит реализацию алгоритма MD5. 
  * Вы можете рассчитывать, что все файлы помещаются в память. 
  * Можно написать решение, состоящее из четырех содержательных строк. 

##### Модификации
* Простая
  * Класс должен иметь имя `CalcSHA256` и подсчитывать [SHA-256](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm).
* Усложненная
  * Напишите простой аналог утилиты [sha256sum](http://linux.die.net/man/1/sha256sum)
  * Класс должен называться `SHA256Sum`
  * Список файлов для хэширования передается в виде аргументов командной строки
  * Если список файлов пуст, то хэшируется стандартный ввод а именем файла считается `-`
  * Вывод хэшей осуществляется в формате `<хэш> <имя файла>`

### Домашнее задание 2. Бинарный поиск
* Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве. 
* На вход подается целое число `x` и массив целых чисел `a`, отсортированный по невозрастанию. Требуется найти минимальное значение индекса `i`, при котором `a[i] <= x`. 
* Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для циклов должны быть указаны инварианты. 
* Интерфейс программы.
  * Имя основного класса — `BinarySearch`.
  * Первый аргумент командной строки — число `x`.
  * Последующие аргументы командной строки — элементы массива `a`.
* Пример запуска: `java BinarySearch 3 5 4 3 2 1`. Ожидаемый результат: `2`. 

##### Модификации
* Простая
  * Если в массиве `a` отсутствует элемент, равный `x`, то требуется вывести индекс вставки в формате, определенном в `Arrays.binarySearch`.
  * Класс должен иметь имя `BinarySearchMissing`.
* Усложненная
  * Требуется вывести два числа: начало и длину диапазона элементов, равных `x`. Если таких элементов нет, то следует вывести пустой диапазон, у которого левая граница совпадает с местом вставки элемента `x`.
  * Не допускается использование типов `long` и `BigInteger`.
  * Класс должен иметь имя `BinarySearchSpan`.

### Домашнее задание 3. Очередь на массиве
* Найдите инвариант структуры данных «очередь». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия.
* Реализуйте классы, представляющие циклическую очередь с применением массива.
  * Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.
  * Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
  * Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
  * Должны быть реализованы следующие функции (процедуры) / методы:
    * `enqueue` – добавить элемент в очередь;
    * `element` – первый элемент в очереди;
    * `dequeue` – удалить и вернуть первый элемент в очереди;
    * `size` – текущий размер очереди;
    * `isEmpty` – является ли очередь пустой;
    * `clear` – удалить все элементы из очереди.
  * Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
  * Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
* Напишите тесты реализованным классам.

##### Модификации
* Простая
  * Реализовать метод `toArray`, возвращающий массив, содержащий элементы, лежащие в очереди в порядке от головы к хвосту.
